## Семантика exactly-once для клиента RSM

Будем назначать каждому запросу некоторый уникальный id. Это может быть хэш запроса или сгенерированный клиентом UUID,
или пара из id клиента и хэша/UUID, или ещё что-то достаточно уникальное. Вместе с каждым запросом
(в том числе вместе с ретраем) клиент должен будет посылать id этого запроса
(если использовать хэши, то клиент может вообще об этом не задумываться и просто ретраить).
Идентификаторы запроса и всех его ретраев должны совпадать, идентификаторы различных запросов тоже должны бать разными
(вероятности коллизии хороших хэшей и совпадения UUID настолько малы, что их можно проигнорировать).

Внутри системы будем вместе с операцией записывать в лог репликации её id запроса.
В памяти (и в снэпшотах RSM) будем поддерживать множество id успешно выполненных (закоммиченных) запросов.
Таким образом, для каждого запроса мы сможем легко понять вполнен ли он, и если выполнен, сразу ответить клиенту,
а если нет - дописать в лог и дождаться коммита (если в логе уже была эта запись, но она ещё не закоммичена, то просто дождаться).

Вроде такое решение должно работать. Но недолго.
В какой-то момент множество id успешных запросов заполнит всю память, поэтому хранить их все постоянно - плохая идея.
Самое простое, что можно с этим сделать - хранить только последние N штук или только id за последние T секунд.
Но тогда exactly-once сломается в случае, если клиент пытался получить подтверждение слишком долго (например, у него были проблемы с сетью).

Чтобы решить эту проблему, заставим клиента вместе с каждым запросом отправлять также id предыдущего запроса, для которого он получил подтверждение.
Этот id может быть пустым, если это первый запрос клиента, или если он забыл, что посылал раньше (например, из-за внезапного падения).
Если клиент обещает, что он не злобный буратино, и что он не будет снова посылать нам запросы, для которых он подтвердил получение подтверждения,
то мы можем спокойно удалить id этих запросов из множества в памяти (и не записывать в следующий снэпшот состояния).
Также будем записывать эти id в лог репликации вместе с операциями
(т.е. для каждой операции в логе будет записан её id и id предыдущей операции, для которой клиент получил подтверждение).
Таким образом, при восстановлении состояния RSM из лога, мы сможем легко понять,
какие id нужно добавить к множеству успешно выполненных запросов, а какие убрать из него.

Из-за падений клиентов могут постепенно накапливаться "мусорные" id выполненных запросов, которые никто не будет ретраить.
Чтобы их не становилось слишком много, можно предусмотреть механизм ручного удаления таких id администратором,
например, с помошью дописывания в лог служебной операции "забудь все id, которые старше одного месяца"
(вероятно, мы уже храним в логе таймстемпы операций для каки-то других целей).
