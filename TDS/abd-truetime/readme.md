## TrueTime и атомарный регистр

Итак, чтобы не сломать корректность алгоритма ABD, которая была доказана для операции записи с фазой кворумного чтения,
нам нужно предоставить те же гарантии на таймстемпы операций записи 
(эта фаза нужна только для получения таймстемпов), а именно:
 - если операция записи $`w_1`$ в физическом времени завершилась раньше, чем началась операция записи $`w_2`$,
то таймстемп операции $`w_1`$ строго меньше таймстемпа операции $`w_2`$

Реализуем операцию записи примерно следующим образом:
```c++
void ABD::write(T value) {
    auto write_timestamp = TrueTime::now().R;
    writeImpl(value, write_timestamp);
    while (TrueTime::now().L <= write_timestamp)
        std::this_thread::yield();
}
```
Т.е. в качестве таймстемпа операции записи выберем правую границу физического времени на момент начала операции
(`write_timestamp` будет больше или равен физическому времени начала операции).
Затем, выполнив запись, прежде чем завершить операцию и вернуть ответ пользователю,
дождёмся когда момент `write_timestamp` в физическом времени гарантированно пройдёт,
т.е. при завершении операции будет выполнено условие `write_timestamp < TrueTime::now().L`
и выбранный таймстемп будет меньше, чем физическое время завершения операции.
Таким образом, если другая операция записи в физическом времени начнётся позже этой операции,
`TrueTime::now().R` вернёт для неё строго больший таймстемп, что нам и нужно.

Лишнее ожидание на пустом месте не выглядит чем-то страшным, поскольку на практике в большинсте случаев
TrueTime должен возвращать достаточно короткие отрезки (ждать придётся недолго),
а гарантий на время работы операции мы всё равно не даём.
