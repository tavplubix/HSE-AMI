## Timestamp Oracle

Возьмём ABD. Утверждается, что он отказоустойчив и на каждую операцию записи умеет выдавать монотонный таймстемп, удовлетворяющий условиям задачи.
Значит, на каждый запрос `GetTimestamp` просто будем писать что-нибудь в ABD-регитр и возвращать таймстемп этой записи. Всё.

Оптимизация: чтобы ABD-реплики не ходили на диск на каждый запрос, в качестве таймстемпа будем использовать кортеж `(epoch_number, timestamp, host_id)`,
где `epoch_number` - некоторое монотонно возрастающее число, которое реплики хранят на диске.
Оно увеличивается на 1 при восстановлении реплики после падения.
Если какая-либо реплика увидела значение `epoch_number` больше, чем у неё,
 то она должна перезаписать своё значение на диске.
Это позволяет хранить `timestamp` только в памяти, обращения к диску нужны только для увеличения `epoch_number` после перезапуска одной из реплик, что бывает редко.

## Альтернативное решение

Возьмём RAFT. Прогонять каждый запрос `GetTimestamp` через лог репликации слишком дорого,
поэтому будем использовать лог для выделения диапазонов таймстемпов, а текущий счётчик внутри выделенного диапазона будем поддерживать только в памяти лидера,
который и будет выдавать таймстемпы. Если с ним что-то случится (лидер упадёт),
просто выделим новый диапазон и начнём выдавать таймстемпы из него.

Проблема: в случае с двумя лидерами старый лидер может выдать клиенту таймстемп из старого (меньшего) диапазона,
тогда как новый лидер уже начал выдавать таймстемпы из нового (большего) диапазона. Её можно решить примерно таким костылём:
если лидер более $`T`$ времени не получает от кворума ответы на пинги, то он перестаёт выдавать таймстемпы из текущего диапазона
(при попытке выделить новый диапазон через RAFT он, скорее всего, узнает, что он больше не лидер).
При перевыборах, новый лидер ждёт $`cT, \ c > 1`$ времени, прежде чем начать отвечать на запросы клиентов,
чтобы дождаться остановки старого лидера (при $`c`$ близких к 1 это может не работать из-за неточных часов).

Таким образом, при нормальном функционировании сети и узлов, мы будем выдавать таймстемпы максимально быстро
(нужно только увеличить счётчик в памяти, выделение диапазонов происходит редко), но в случае сбоев запросы к системе повиснут на время $`cT`$.


## Решение с ZooKeeper

Возьмём ZooKeeper. Будем создавать sequential-ноды по некоторому пути. ZooKeeper выдаст каждой такой ноде монотонно возрастающий номер, который можно использовать как таймстемп. Старые ноды нужно удалять, чтобы ZooKeeper не страдал от ожирения (или можно создавать ephemeral sequential ноды и периодически сбрасывать сессию, в которой мы получаем таймстемпы).
